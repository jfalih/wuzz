diff --git a/node_modules/react-native-collapsible-tab-view/lib/module/Container.js b/node_modules/react-native-collapsible-tab-view/lib/module/Container.js
index 2f5c338..c8f8eba 100644
--- a/node_modules/react-native-collapsible-tab-view/lib/module/Container.js
+++ b/node_modules/react-native-collapsible-tab-view/lib/module/Container.js
@@ -1,15 +1,45 @@
-function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+function _extends() {
+  _extends =
+    Object.assign ||
+    function (target) {
+      for (var i = 1; i < arguments.length; i++) {
+        var source = arguments[i];
+        for (var key in source) {
+          if (Object.prototype.hasOwnProperty.call(source, key)) {
+            target[key] = source[key];
+          }
+        }
+      }
+      return target;
+    };
+  return _extends.apply(this, arguments);
+}
 
-import React from 'react';
-import { StyleSheet, useWindowDimensions, View } from 'react-native';
-import PagerView from 'react-native-pager-view';
-import Animated, { runOnJS, runOnUI, useAnimatedReaction, useAnimatedStyle, useDerivedValue, useSharedValue, withDelay, withTiming } from 'react-native-reanimated';
-import { Context, TabNameContext } from './Context';
-import { Lazy } from './Lazy';
-import { MaterialTabBar, TABBAR_HEIGHT } from './MaterialTabBar';
-import { Tab } from './Tab';
-import { IS_IOS, ONE_FRAME_MS, scrollToImpl } from './helpers';
-import { useAnimatedDynamicRefs, useContainerRef, usePageScrollHandler, useTabProps } from './hooks';
+import React from "react";
+import { StyleSheet, useWindowDimensions, View } from "react-native";
+import PagerView from "react-native-pager-view";
+import Animated, {
+  runOnJS,
+  runOnUI,
+  useAnimatedReaction,
+  useAnimatedStyle,
+  useDerivedValue,
+  useSharedValue,
+  withDelay,
+  withTiming,
+} from "react-native-reanimated";
+import { Context, TabNameContext } from "./Context";
+import { Lazy } from "./Lazy";
+import { MaterialTabBar, TABBAR_HEIGHT } from "./MaterialTabBar";
+import { Tab } from "./Tab";
+import { IS_IOS, ONE_FRAME_MS, scrollToImpl } from "./helpers";
+import {
+  useAnimatedDynamicRefs,
+  useContainerRef,
+  usePageScrollHandler,
+  useTabProps,
+} from "./hooks";
+import { GestureDetector, Gesture } from "react-native-gesture-handler";
 const AnimatedPagerView = Animated.createAnimatedComponent(PagerView);
 /**
  * Basic usage looks like this:
@@ -32,296 +62,505 @@ const AnimatedPagerView = Animated.createAnimatedComponent(PagerView);
  * ```
  */
 
-export const Container = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef((_ref, ref) => {
-  let {
-    initialTabName,
-    headerHeight: initialHeaderHeight,
-    minHeaderHeight = 0,
-    tabBarHeight: initialTabBarHeight = TABBAR_HEIGHT,
-    revealHeaderOnScroll = false,
-    snapThreshold,
-    children,
-    renderHeader,
-    renderTabBar = props => /*#__PURE__*/React.createElement(MaterialTabBar, props),
-    headerContainerStyle,
-    cancelTranslation,
-    containerStyle,
-    lazy,
-    cancelLazyFadeIn,
-    pagerProps,
-    onIndexChange,
-    onTabChange,
-    width: customWidth,
-    allowHeaderOverscroll
-  } = _ref;
-  const containerRef = useContainerRef();
-  const [tabProps, tabNamesArray] = useTabProps(children, Tab);
-  const [refMap, setRef] = useAnimatedDynamicRefs();
-  const windowWidth = useWindowDimensions().width;
-  const width = customWidth !== null && customWidth !== void 0 ? customWidth : windowWidth;
-  const containerHeight = useSharedValue(undefined);
-  const tabBarHeight = useSharedValue(initialTabBarHeight);
-  const headerHeight = useSharedValue(!renderHeader ? 0 : initialHeaderHeight);
-  const contentInset = useDerivedValue(() => {
-    if (allowHeaderOverscroll) return 0; // necessary for the refresh control on iOS to be positioned underneath the header
-    // this also adjusts the scroll bars to clamp underneath the header area
+export const Container = /*#__PURE__*/ React.memo(
+  /*#__PURE__*/ React.forwardRef((_ref, ref) => {
+    let {
+      initialTabName,
+      headerHeight: initialHeaderHeight,
+      minHeaderHeight = 0,
+      hasTouchableHeader = false,
+      tabBarHeight: initialTabBarHeight = TABBAR_HEIGHT,
+      revealHeaderOnScroll = false,
+      snapThreshold,
+      children,
+      renderHeader,
+      renderTabBar = (props) =>
+        /*#__PURE__*/ React.createElement(MaterialTabBar, props),
+      headerContainerStyle,
+      cancelTranslation,
+      containerStyle,
+      lazy,
+      cancelLazyFadeIn,
+      pagerProps,
+      onIndexChange,
+      onTabChange,
+      width: customWidth,
+      allowHeaderOverscroll,
+    } = _ref;
+    const containerRef = useContainerRef();
+    const [tabProps, tabNamesArray] = useTabProps(children, Tab);
+    const [refMap, setRef] = useAnimatedDynamicRefs();
+    const windowWidth = useWindowDimensions().width;
+    const width =
+      customWidth !== null && customWidth !== void 0
+        ? customWidth
+        : windowWidth;
+    const containerHeight = useSharedValue(undefined);
+    const tabBarHeight = useSharedValue(initialTabBarHeight);
+    const headerHeight = useSharedValue(
+      !renderHeader ? 0 : initialHeaderHeight,
+    );
+    const contentInset = useDerivedValue(() => {
+      if (allowHeaderOverscroll) return 0; // necessary for the refresh control on iOS to be positioned underneath the header
+      // this also adjusts the scroll bars to clamp underneath the header area
 
-    return IS_IOS ? (headerHeight.value || 0) + (tabBarHeight.value || 0) : 0;
-  });
-  const snappingTo = useSharedValue(0);
-  const offset = useSharedValue(0);
-  const accScrollY = useSharedValue(0);
-  const oldAccScrollY = useSharedValue(0);
-  const accDiffClamp = useSharedValue(0);
-  const scrollYCurrent = useSharedValue(0);
-  const scrollY = useSharedValue(tabNamesArray.map(() => 0));
-  const contentHeights = useSharedValue(tabNamesArray.map(() => 0));
-  const tabNames = useDerivedValue(() => tabNamesArray, [tabNamesArray]);
-  const index = useSharedValue(initialTabName ? tabNames.value.findIndex(n => n === initialTabName) : 0);
-  const [data, setData] = React.useState(tabNamesArray);
-  React.useEffect(() => {
-    setData(tabNamesArray);
-  }, [tabNamesArray]);
-  const focusedTab = useDerivedValue(() => {
-    return tabNames.value[index.value];
-  }, [tabNames]);
-  const calculateNextOffset = useSharedValue(index.value);
-  const headerScrollDistance = useDerivedValue(() => {
-    return headerHeight.value !== undefined ? headerHeight.value - minHeaderHeight : 0;
-  }, [headerHeight, minHeaderHeight]);
-  const indexDecimal = useSharedValue(index.value);
-  const afterRender = useSharedValue(0);
-  React.useEffect(() => {
-    afterRender.value = withDelay(ONE_FRAME_MS * 5, withTiming(1, {
-      duration: 0
-    }));
-  }, [afterRender, tabNamesArray]);
+      return IS_IOS ? (headerHeight.value || 0) + (tabBarHeight.value || 0) : 0;
+    });
+    const snappingTo = useSharedValue(0);
+    const offset = useSharedValue(0);
+    const accScrollY = useSharedValue(0);
+    const oldAccScrollY = useSharedValue(0);
+    const accDiffClamp = useSharedValue(0);
+    const scrollYCurrent = useSharedValue(0);
+    const scrollY = useSharedValue(tabNamesArray.map(() => 0));
+    const isSlidingTopContainer = useSharedValue(false);
+    const isSlidingTopContainerPrev = useSharedValue(false);
+    const isTopContainerOutOfSync = useSharedValue(false);
+    const contentHeights = useSharedValue(tabNamesArray.map(() => 0));
+    const tabNames = useDerivedValue(() => tabNamesArray, [tabNamesArray]);
+    const index = useSharedValue(
+      initialTabName
+        ? tabNames.value.findIndex((n) => n === initialTabName)
+        : 0,
+    );
+    const [data, setData] = React.useState(tabNamesArray);
+    React.useEffect(() => {
+      setData(tabNamesArray);
+    }, [tabNamesArray]);
+    const focusedTab = useDerivedValue(() => {
+      return tabNames.value[index.value];
+    }, [tabNames]);
+    const calculateNextOffset = useSharedValue(index.value);
+    const headerScrollDistance = useDerivedValue(() => {
+      return headerHeight.value !== undefined
+        ? headerHeight.value - minHeaderHeight
+        : 0;
+    }, [headerHeight, minHeaderHeight]);
+    const indexDecimal = useSharedValue(index.value);
+    const afterRender = useSharedValue(0);
+    React.useEffect(() => {
+      afterRender.value = withDelay(
+        ONE_FRAME_MS * 5,
+        withTiming(1, {
+          duration: 0,
+        }),
+      );
+    }, [afterRender, tabNamesArray]);
 
-  const resyncTabScroll = () => {
-    'worklet';
+    const resyncTabScroll = () => {
+      "worklet";
 
-    for (const name of tabNamesArray) {
-      scrollToImpl(refMap[name], 0, scrollYCurrent.value - contentInset.value, false);
-    }
-  }; // the purpose of this is to scroll to the proper position if dynamic tabs are changing
+      for (const name of tabNamesArray) {
+        scrollToImpl(
+          refMap[name],
+          0,
+          scrollYCurrent.value - contentInset.value,
+          false,
+        );
+      }
+    }; // the purpose of this is to scroll to the proper position if dynamic tabs are changing
 
+    useAnimatedReaction(
+      () => {
+        return afterRender.value === 1;
+      },
+      (trigger) => {
+        if (trigger) {
+          afterRender.value = 0;
+          resyncTabScroll();
+        }
+      },
+      [tabNamesArray, refMap, afterRender, contentInset],
+    ); // derived from scrollX
+    // calculate the next offset and index if swiping
+    // if scrollX changes from tab press,
+    // the same logic must be done, but knowing
+    // the next index in advance
 
-  useAnimatedReaction(() => {
-    return afterRender.value === 1;
-  }, trigger => {
-    if (trigger) {
-      afterRender.value = 0;
-      resyncTabScroll();
-    }
-  }, [tabNamesArray, refMap, afterRender, contentInset]); // derived from scrollX
-  // calculate the next offset and index if swiping
-  // if scrollX changes from tab press,
-  // the same logic must be done, but knowing
-  // the next index in advance
+    useAnimatedReaction(
+      () => {
+        const nextIndex = Math.round(indexDecimal.value);
+        return nextIndex;
+      },
+      (nextIndex) => {
+        if (nextIndex !== null && nextIndex !== index.value) {
+          calculateNextOffset.value = nextIndex;
+        }
+      },
+      [],
+    );
+    const propagateTabChange = React.useCallback(
+      (change) => {
+        onTabChange === null || onTabChange === void 0
+          ? void 0
+          : onTabChange(change);
+        onIndexChange === null || onIndexChange === void 0
+          ? void 0
+          : onIndexChange(change.index);
+      },
+      [onIndexChange, onTabChange],
+    );
+    useAnimatedReaction(
+      () => {
+        return calculateNextOffset.value;
+      },
+      (i) => {
+        if (i !== index.value) {
+          offset.value =
+            scrollY.value[index.value] - scrollY.value[i] + offset.value;
+          runOnJS(propagateTabChange)({
+            prevIndex: index.value,
+            index: i,
+            prevTabName: tabNames.value[index.value],
+            tabName: tabNames.value[i],
+          });
+          index.value = i;
+          scrollYCurrent.value = scrollY.value[index.value] || 0;
+        }
+      },
+      [],
+    );
+    useAnimatedReaction(
+      () => headerHeight.value,
+      (_current, prev) => {
+        if (prev === undefined) {
+          // sync scroll if we started with undefined header height
+          resyncTabScroll();
+        }
+      },
+    );
+    const headerTranslateY = useDerivedValue(() => {
+      return revealHeaderOnScroll
+        ? -accDiffClamp.value
+        : -Math.min(scrollYCurrent.value, headerScrollDistance.value);
+    }, [revealHeaderOnScroll]);
+    const stylez = useAnimatedStyle(() => {
+      return {
+        transform: [
+          {
+            translateY: headerTranslateY.value,
+          },
+        ],
+      };
+    }, [revealHeaderOnScroll]);
+    const getHeaderHeight = React.useCallback(
+      (event) => {
+        const height = event.nativeEvent.layout.height;
 
-  useAnimatedReaction(() => {
-    const nextIndex = Math.round(indexDecimal.value);
-    return nextIndex;
-  }, nextIndex => {
-    if (nextIndex !== null && nextIndex !== index.value) {
-      calculateNextOffset.value = nextIndex;
-    }
-  }, []);
-  const propagateTabChange = React.useCallback(change => {
-    onTabChange === null || onTabChange === void 0 ? void 0 : onTabChange(change);
-    onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(change.index);
-  }, [onIndexChange, onTabChange]);
-  useAnimatedReaction(() => {
-    return calculateNextOffset.value;
-  }, i => {
-    if (i !== index.value) {
-      offset.value = scrollY.value[index.value] - scrollY.value[i] + offset.value;
-      runOnJS(propagateTabChange)({
-        prevIndex: index.value,
-        index: i,
-        prevTabName: tabNames.value[index.value],
-        tabName: tabNames.value[i]
-      });
-      index.value = i;
-      scrollYCurrent.value = scrollY.value[index.value] || 0;
-    }
-  }, []);
-  useAnimatedReaction(() => headerHeight.value, (_current, prev) => {
-    if (prev === undefined) {
-      // sync scroll if we started with undefined header height
-      resyncTabScroll();
-    }
-  });
-  const headerTranslateY = useDerivedValue(() => {
-    return revealHeaderOnScroll ? -accDiffClamp.value : -Math.min(scrollYCurrent.value, headerScrollDistance.value);
-  }, [revealHeaderOnScroll]);
-  const stylez = useAnimatedStyle(() => {
-    return {
-      transform: [{
-        translateY: headerTranslateY.value
-      }]
-    };
-  }, [revealHeaderOnScroll]);
-  const getHeaderHeight = React.useCallback(event => {
-    const height = event.nativeEvent.layout.height;
+        if (headerHeight.value !== height) {
+          headerHeight.value = height;
+        }
+      },
+      [headerHeight],
+    );
+    const getTabBarHeight = React.useCallback(
+      (event) => {
+        const height = event.nativeEvent.layout.height;
+        if (tabBarHeight.value !== height) tabBarHeight.value = height;
+      },
+      [tabBarHeight],
+    );
+    const onLayout = React.useCallback(
+      (event) => {
+        const height = event.nativeEvent.layout.height;
+        if (containerHeight.value !== height) containerHeight.value = height;
+      },
+      [containerHeight],
+    );
+    const onTabPress = React.useCallback(
+      (name) => {
+        const i = tabNames.value.findIndex((n) => n === name);
 
-    if (headerHeight.value !== height) {
-      headerHeight.value = height;
-    }
-  }, [headerHeight]);
-  const getTabBarHeight = React.useCallback(event => {
-    const height = event.nativeEvent.layout.height;
-    if (tabBarHeight.value !== height) tabBarHeight.value = height;
-  }, [tabBarHeight]);
-  const onLayout = React.useCallback(event => {
-    const height = event.nativeEvent.layout.height;
-    if (containerHeight.value !== height) containerHeight.value = height;
-  }, [containerHeight]);
-  const onTabPress = React.useCallback(name => {
-    const i = tabNames.value.findIndex(n => n === name);
+        if (name === focusedTab.value) {
+          const ref = refMap[name];
+          runOnUI(scrollToImpl)(
+            ref,
+            0,
+            headerScrollDistance.value - contentInset.value,
+            true,
+          );
+        } else {
+          var _containerRef$current;
 
-    if (name === focusedTab.value) {
-      const ref = refMap[name];
-      runOnUI(scrollToImpl)(ref, 0, headerScrollDistance.value - contentInset.value, true);
-    } else {
-      var _containerRef$current;
+          (_containerRef$current = containerRef.current) === null ||
+          _containerRef$current === void 0
+            ? void 0
+            : _containerRef$current.setPage(i);
+        }
+      }, // eslint-disable-next-line react-hooks/exhaustive-deps
+      [containerRef, refMap, contentInset],
+    );
+    React.useEffect(() => {
+      if (index.value >= tabNamesArray.length) {
+        onTabPress(tabNamesArray[tabNamesArray.length - 1]);
+      }
+    }, [index.value, onTabPress, tabNamesArray]);
+    const pageScrollHandler = usePageScrollHandler({
+      onPageScroll: (e) => {
+        "worklet";
 
-      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.setPage(i);
-    }
-  }, // eslint-disable-next-line react-hooks/exhaustive-deps
-  [containerRef, refMap, contentInset]);
-  React.useEffect(() => {
-    if (index.value >= tabNamesArray.length) {
-      onTabPress(tabNamesArray[tabNamesArray.length - 1]);
-    }
-  }, [index.value, onTabPress, tabNamesArray]);
-  const pageScrollHandler = usePageScrollHandler({
-    onPageScroll: e => {
-      'worklet';
+        indexDecimal.value = e.position + e.offset;
+      },
+    });
+    React.useImperativeHandle(
+      ref,
+      () => ({
+        setIndex: (index) => {
+          const name = tabNames.value[index];
+          onTabPress(name);
+          return true;
+        },
+        jumpToTab: (name) => {
+          onTabPress(name);
+          return true;
+        },
+        getFocusedTab: () => {
+          return tabNames.value[index.value];
+        },
+        getCurrentIndex: () => {
+          return index.value;
+        },
+      }), // eslint-disable-next-line react-hooks/exhaustive-deps
+      [onTabPress],
+    );
 
-      indexDecimal.value = e.position + e.offset;
-    }
-  });
-  React.useImperativeHandle(ref, () => ({
-    setIndex: index => {
-      const name = tabNames.value[index];
-      onTabPress(name);
-      return true;
-    },
-    jumpToTab: name => {
-      onTabPress(name);
-      return true;
-    },
-    getFocusedTab: () => {
-      return tabNames.value[index.value];
-    },
-    getCurrentIndex: () => {
-      return index.value;
-    }
-  }), // eslint-disable-next-line react-hooks/exhaustive-deps
-  [onTabPress]);
-  return /*#__PURE__*/React.createElement(Context.Provider, {
-    value: {
-      contentInset,
-      tabBarHeight,
-      headerHeight,
-      refMap,
-      tabNames,
-      index,
-      snapThreshold,
-      revealHeaderOnScroll,
-      focusedTab,
-      accDiffClamp,
-      indexDecimal,
-      containerHeight,
-      minHeaderHeight,
-      scrollYCurrent,
-      scrollY,
-      setRef,
-      headerScrollDistance,
-      accScrollY,
-      oldAccScrollY,
-      offset,
-      snappingTo,
-      contentHeights,
-      headerTranslateY,
-      width,
-      allowHeaderOverscroll
-    }
-  }, /*#__PURE__*/React.createElement(Animated.View, {
-    style: [styles.container, {
-      width
-    }, containerStyle],
-    onLayout: onLayout,
-    pointerEvents: "box-none"
-  }, /*#__PURE__*/React.createElement(Animated.View, {
-    pointerEvents: "box-none",
-    style: [styles.topContainer, headerContainerStyle, !cancelTranslation && stylez]
-  }, /*#__PURE__*/React.createElement(View, {
-    style: [styles.container, styles.headerContainer],
-    onLayout: getHeaderHeight,
-    pointerEvents: "box-none"
-  }, renderHeader && renderHeader({
-    containerRef,
-    index,
-    tabNames: tabNamesArray,
-    focusedTab,
-    indexDecimal,
-    onTabPress,
-    tabProps
-  })), /*#__PURE__*/React.createElement(View, {
-    style: [styles.container, styles.tabBarContainer],
-    onLayout: getTabBarHeight,
-    pointerEvents: "box-none"
-  }, renderTabBar && renderTabBar({
-    containerRef,
-    index,
-    tabNames: tabNamesArray,
-    focusedTab,
-    indexDecimal,
-    width,
-    onTabPress,
-    tabProps
-  }))), /*#__PURE__*/React.createElement(AnimatedPagerView, _extends({
-    ref: containerRef,
-    onPageScroll: pageScrollHandler,
-    initialPage: index.value
-  }, pagerProps, {
-    style: [pagerProps === null || pagerProps === void 0 ? void 0 : pagerProps.style, StyleSheet.absoluteFill]
-  }), data.map((tabName, i) => {
-    return /*#__PURE__*/React.createElement(View, {
-      key: i
-    }, /*#__PURE__*/React.createElement(TabNameContext.Provider, {
-      value: tabName
-    }, /*#__PURE__*/React.createElement(Lazy, {
-      startMounted: lazy ? undefined : true,
-      cancelLazyFadeIn: !lazy ? true : !!cancelLazyFadeIn
-    }, React.Children.toArray(children)[i])));
-  }))));
-}));
+    const panGestureScrollYCtx = useSharedValue(0);
+    const panGesture = useMemo(
+      () =>
+        Gesture.Pan()
+          .activeOffsetY([-10, 10])
+          .onUpdate((event) => {
+            if (!isSlidingTopContainer.value) {
+              panGestureScrollYCtx.value = scrollYCurrent.value;
+              isSlidingTopContainer.value = true;
+              return;
+            }
+
+            scrollYCurrent.value = interpolate(
+              -event.translationY + panGestureScrollYCtx.value,
+              [0, headerScrollDistance.value],
+              [0, headerScrollDistance.value],
+              Extrapolate.CLAMP,
+            );
+          })
+          .onEnd((event) => {
+            if (!isSlidingTopContainer.value) return;
+
+            panGestureScrollYCtx.value = 0;
+            scrollYCurrent.value = withDecay(
+              {
+                velocity: -event.velocityY,
+                clamp: [0, headerScrollDistance.value],
+                deceleration: IS_IOS ? 0.998 : 0.99,
+              },
+              (finished) => {
+                isSlidingTopContainer.value = false;
+                isTopContainerOutOfSync.value = finished;
+              },
+            );
+          }),
+      [],
+    );
+
+    useAnimatedReaction(
+      () => scrollYCurrent.value - contentInset.value,
+      (nextPosition, previousPosition) => {
+        if (nextPosition !== previousPosition && isSlidingTopContainer.value) {
+          resyncTabScroll();
+        }
+      },
+    );
+
+    /* Syncs the scroll of the active tab once we complete the scroll gesture 
+  on the header and the decay animation completes with success
+   */
+    useAnimatedReaction(
+      () => {
+        return (
+          isSlidingTopContainer.value !== isSlidingTopContainerPrev.value &&
+          isTopContainerOutOfSync.value
+        );
+      },
+      (result) => {
+        isSlidingTopContainerPrev.value = isSlidingTopContainer.value;
+
+        if (!result) return;
+        if (isSlidingTopContainer.value === true) return;
+
+        resyncTabScroll();
+
+        isTopContainerOutOfSync.value = false;
+      },
+    );
+
+    const headerAndTabBar = /*#__PURE__*/ React.createElement(
+      Animated.View,
+      {
+        pointerEvents: "box-none",
+        style: [
+          styles.topContainer,
+          headerContainerStyle,
+          !cancelTranslation && stylez,
+        ],
+      },
+      /*#__PURE__*/ React.createElement(
+        View,
+        {
+          style: [styles.container, styles.headerContainer],
+          onLayout: getHeaderHeight,
+          pointerEvents: "box-none",
+        },
+        renderHeader &&
+          renderHeader({
+            containerRef,
+            index,
+            tabNames: tabNamesArray,
+            focusedTab,
+            indexDecimal,
+            onTabPress,
+            tabProps,
+          }),
+      ),
+      /*#__PURE__*/ React.createElement(
+        View,
+        {
+          style: [styles.container, styles.tabBarContainer],
+          onLayout: getTabBarHeight,
+          pointerEvents: "box-none",
+        },
+        renderTabBar &&
+          renderTabBar({
+            containerRef,
+            index,
+            tabNames: tabNamesArray,
+            focusedTab,
+            indexDecimal,
+            width,
+            onTabPress,
+            tabProps,
+          }),
+      ),
+    );
+
+    return /*#__PURE__*/ React.createElement(
+      Context.Provider,
+      {
+        value: {
+          contentInset,
+          tabBarHeight,
+          headerHeight,
+          refMap,
+          tabNames,
+          index,
+          snapThreshold,
+          revealHeaderOnScroll,
+          focusedTab,
+          accDiffClamp,
+          indexDecimal,
+          containerHeight,
+          minHeaderHeight,
+          scrollYCurrent,
+          scrollY,
+          setRef,
+          headerScrollDistance,
+          accScrollY,
+          oldAccScrollY,
+          offset,
+          snappingTo,
+          contentHeights,
+          headerTranslateY,
+          width,
+          allowHeaderOverscroll,
+        },
+      },
+      /*#__PURE__*/ React.createElement(
+        Animated.View,
+        {
+          style: [
+            styles.container,
+            {
+              width,
+            },
+            containerStyle,
+          ],
+          onLayout: onLayout,
+          pointerEvents: "box-none",
+        },
+        hasTouchableHeader
+          ? /* #__PURE__*/ React.createElement(
+              GestureDetector,
+              { gesture: panGesture },
+              headerAndTabBar,
+            )
+          : headerAndTabBar,
+        /*#__PURE__*/ React.createElement(
+          AnimatedPagerView,
+          _extends(
+            {
+              ref: containerRef,
+              onPageScroll: pageScrollHandler,
+              initialPage: index.value,
+            },
+            pagerProps,
+            {
+              style: [
+                pagerProps === null || pagerProps === void 0
+                  ? void 0
+                  : pagerProps.style,
+                StyleSheet.absoluteFill,
+              ],
+            },
+          ),
+          data.map((tabName, i) => {
+            return /*#__PURE__*/ React.createElement(
+              View,
+              {
+                key: i,
+              },
+              /*#__PURE__*/ React.createElement(
+                TabNameContext.Provider,
+                {
+                  value: tabName,
+                },
+                /*#__PURE__*/ React.createElement(
+                  Lazy,
+                  {
+                    startMounted: lazy ? undefined : true,
+                    cancelLazyFadeIn: !lazy ? true : !!cancelLazyFadeIn,
+                  },
+                  React.Children.toArray(children)[i],
+                ),
+              ),
+            );
+          }),
+        ),
+      ),
+    );
+  }),
+);
 const styles = StyleSheet.create({
   container: {
-    flex: 1
+    flex: 1,
   },
   topContainer: {
-    position: 'absolute',
+    position: "absolute",
     zIndex: 100,
-    width: '100%',
-    backgroundColor: 'white',
-    shadowColor: '#000000',
+    width: "100%",
+    backgroundColor: "white",
+    shadowColor: "#000000",
     shadowOffset: {
       width: 0,
-      height: 2
+      height: 2,
     },
     shadowOpacity: 0.23,
     shadowRadius: 2.62,
-    elevation: 4
+    elevation: 4,
   },
   tabBarContainer: {
-    zIndex: 1
+    zIndex: 1,
   },
   headerContainer: {
-    zIndex: 2
-  }
+    zIndex: 2,
+  },
 });
 //# sourceMappingURL=Container.js.map
diff --git a/node_modules/react-native-collapsible-tab-view/lib/typescript/src/types.d.ts b/node_modules/react-native-collapsible-tab-view/lib/typescript/src/types.d.ts
index a5041df..30f509d 100644
--- a/node_modules/react-native-collapsible-tab-view/lib/typescript/src/types.d.ts
+++ b/node_modules/react-native-collapsible-tab-view/lib/typescript/src/types.d.ts
@@ -1,202 +1,229 @@
-import React, { ComponentProps } from 'react';
-import { FlatList, ScrollView, SectionList, StyleProp, ViewStyle } from 'react-native';
-import PagerView, { PagerViewProps } from 'react-native-pager-view';
-import Animated from 'react-native-reanimated';
+import React, { ComponentProps } from "react";
+import {
+  FlatList,
+  ScrollView,
+  SectionList,
+  StyleProp,
+  ViewStyle,
+} from "react-native";
+import PagerView, { PagerViewProps } from "react-native-pager-view";
+import Animated from "react-native-reanimated";
 export declare type ContainerRef = PagerView;
-export declare type RefComponent = FlatList<any> | ScrollView | Animated.ScrollView | SectionList<any>;
+export declare type RefComponent =
+  | FlatList<any>
+  | ScrollView
+  | Animated.ScrollView
+  | SectionList<any>;
 export declare type Ref<T extends RefComponent> = React.RefObject<T>;
 export declare type TabName = string;
 export declare type RefHandler<T extends TabName = TabName> = {
-    jumpToTab: (name: T) => boolean;
-    setIndex: (index: number) => boolean;
-    getFocusedTab: () => T;
-    getCurrentIndex: () => number;
+  jumpToTab: (name: T) => boolean;
+  setIndex: (index: number) => boolean;
+  getFocusedTab: () => T;
+  getCurrentIndex: () => number;
 };
-export declare type CollapsibleRef<T extends TabName = TabName> = RefHandler<T> | undefined;
+export declare type CollapsibleRef<T extends TabName = TabName> =
+  | RefHandler<T>
+  | undefined;
 export declare type TabBarProps<T extends TabName = TabName> = {
-    indexDecimal: Animated.SharedValue<number>;
-    focusedTab: Animated.SharedValue<T>;
-    tabNames: T[];
-    index: Animated.SharedValue<number>;
-    containerRef: React.RefObject<ContainerRef>;
-    onTabPress: (name: T) => void;
-    tabProps: TabsWithProps<T>;
-    /**
-     * Custom width of the tabbar. Defaults to the window width.
-     */
-    width?: number;
+  indexDecimal: Animated.SharedValue<number>;
+  focusedTab: Animated.SharedValue<T>;
+  tabNames: T[];
+  index: Animated.SharedValue<number>;
+  containerRef: React.RefObject<ContainerRef>;
+  onTabPress: (name: T) => void;
+  tabProps: TabsWithProps<T>;
+  /**
+   * Custom width of the tabbar. Defaults to the window width.
+   */
+  width?: number;
 };
 export declare type IndexChangeEventData<T extends TabName = TabName> = {
-    prevIndex: number;
-    index: number;
-    prevTabName: T;
-    tabName: T;
+  prevIndex: number;
+  index: number;
+  prevTabName: T;
+  tabName: T;
 };
-export declare type OnTabChangeCallback<T extends TabName = TabName> = (data: IndexChangeEventData<T>) => void;
-export declare type TabReactElement<T extends TabName = TabName> = React.ReactElement<TabProps<T>> | null;
+export declare type OnTabChangeCallback<T extends TabName = TabName> = (
+  data: IndexChangeEventData<T>,
+) => void;
+export declare type TabReactElement<T extends TabName = TabName> =
+  React.ReactElement<TabProps<T>> | null;
 export declare type CollapsibleProps = {
-    initialTabName?: TabName;
-    /**
-     * Is optional, but will optimize the first render.
-     */
-    headerHeight?: number;
-    /**
-     * Is optional, but will optimize the first render.
-     */
-    tabBarHeight?: number;
-    /**
-     * Header minimum height when collapsed
-     */
-    minHeaderHeight?: number;
-    /**
-     * Reveal header when scrolling down. Implements diffClamp.
-     */
-    revealHeaderOnScroll?: boolean;
-    /**
-     * Percentage of header height to define as the snap point. A number between
-     * 0 and 1, or `null` to disable snapping.
-     * @default null
-     */
-    snapThreshold?: number | null;
-    children: TabReactElement<TabName>[] | TabReactElement<TabName>;
-    renderHeader?: (props: TabBarProps<TabName>) => React.ReactElement | null;
-    renderTabBar?: (props: TabBarProps<TabName>) => React.ReactElement | null;
-    headerContainerStyle?: StyleProp<Animated.AnimateStyle<ViewStyle>>;
-    containerStyle?: StyleProp<ViewStyle>;
-    cancelTranslation?: boolean;
-    /**
-     * If lazy, will mount the screens only when the tab is visited. There is a
-     * default fade in transition.
-     */
-    lazy?: boolean;
-    cancelLazyFadeIn?: boolean;
-    /**
-     * Props passed to the pager. If you want for example to
-     * disable swiping, you can pass `{ scrollEnabled: false }`
-     */
-    pagerProps?: Omit<PagerViewProps, 'onPageScroll' | 'initialPage'>;
-    /**
-     * Callback fired when the index changes. It receives the current index.
-     */
-    onIndexChange?: (index: number) => void;
-    /**
-     * Callback fired when the tab changes. It receives the previous and current
-     *  index and tabnames.
-     */
-    onTabChange?: OnTabChangeCallback<TabName>;
-    /**
-     * Custom width of the container. Defaults to the window width.
-     */
-    width?: number;
-    /**
-     * Whether the header moves down during overscrolling (for example on pull-to-refresh on iOS) or sticks to the top
-     *
-     * @default false
-     */
-    allowHeaderOverscroll?: boolean;
+  initialTabName?: TabName;
+  /**
+   * Is optional, but will optimize the first render.
+   */
+  headerHeight?: number;
+  /**
+   * Is optional, but will optimize the first render.
+   */
+  tabBarHeight?: number;
+  /**
+   * Header minimum height when collapsed
+   */
+  minHeaderHeight?: number;
+  /**
+   * Reveal header when scrolling down. Implements diffClamp.
+   */
+  revealHeaderOnScroll?: boolean;
+  /**
+   * Allows the header to be scrollable
+   */
+  hasTouchableHeader?: boolean;
+  /**
+   * Percentage of header height to define as the snap point. A number between
+   * 0 and 1, or `null` to disable snapping.
+   * @default null
+   */
+  snapThreshold?: number | null;
+  children: TabReactElement<TabName>[] | TabReactElement<TabName>;
+  renderHeader?: (props: TabBarProps<TabName>) => React.ReactElement | null;
+  renderTabBar?: (props: TabBarProps<TabName>) => React.ReactElement | null;
+  headerContainerStyle?: StyleProp<Animated.AnimateStyle<ViewStyle>>;
+  containerStyle?: StyleProp<ViewStyle>;
+  cancelTranslation?: boolean;
+  /**
+   * If lazy, will mount the screens only when the tab is visited. There is a
+   * default fade in transition.
+   */
+  lazy?: boolean;
+  cancelLazyFadeIn?: boolean;
+  /**
+   * Props passed to the pager. If you want for example to
+   * disable swiping, you can pass `{ scrollEnabled: false }`
+   */
+  pagerProps?: Omit<PagerViewProps, "onPageScroll" | "initialPage">;
+  /**
+   * Callback fired when the index changes. It receives the current index.
+   */
+  onIndexChange?: (index: number) => void;
+  /**
+   * Callback fired when the tab changes. It receives the previous and current
+   *  index and tabnames.
+   */
+  onTabChange?: OnTabChangeCallback<TabName>;
+  /**
+   * Custom width of the container. Defaults to the window width.
+   */
+  width?: number;
+  /**
+   * Whether the header moves down during overscrolling (for example on pull-to-refresh on iOS) or sticks to the top
+   *
+   * @default false
+   */
+  allowHeaderOverscroll?: boolean;
 };
 export declare type ContextType<T extends TabName = TabName> = {
-    headerHeight: Animated.SharedValue<number | undefined>;
-    tabBarHeight: Animated.SharedValue<number | undefined>;
-    revealHeaderOnScroll: boolean;
-    snapThreshold: number | null | undefined;
-    /**
-     * Index value, including decimal points. Use this to interpolate tab
-     * indicators.
-     */
-    indexDecimal: Animated.SharedValue<number>;
-    /**
-     * Tab names, same as the keys of `refMap`.
-     */
-    tabNames: Animated.SharedValue<T[]>;
-    /**
-     * Current index of the pager.
-     */
-    index: Animated.SharedValue<number>;
-    /**
-     * Name of the current focused tab.
-     */
-    focusedTab: Animated.SharedValue<T>;
-    /**
-     * DiffClamp value. It's the current visible header height if
-     * `diffClampEnabled={true}`.
-     */
-    accDiffClamp: Animated.SharedValue<number>;
-    /**
-     * Scroll position of current tab.
-     */
-    scrollYCurrent: Animated.SharedValue<number>;
-    /**
-     * Array of the scroll y position of each tab.
-     */
-    scrollY: Animated.SharedValue<number[]>;
-    containerHeight: Animated.SharedValue<number | undefined>;
-    /**
-     * Object containing the ref of each scrollable component.
-     */
-    refMap: Record<TabName, Ref<RefComponent>>;
-    /**
-     * Set the ref of the scrollable component.
-     */
-    setRef: <TComponent extends RefComponent>(key: T, ref: React.RefObject<TComponent>) => Ref<TComponent>;
-    /**
-     * Max distance allowed to collapse the header.
-     */
-    headerScrollDistance: Animated.SharedValue<number>;
-    /**
-     * Previous addScrollY value.
-     */
-    oldAccScrollY: Animated.SharedValue<number>;
-    /**
-     * Accumulated scroll Y distance. Used to calculate the accDiffClamp value.
-     */
-    accScrollY: Animated.SharedValue<number>;
-    /**
-     * Offset to take the next scrollY as if it were at the same position of the
-     * previous tab.
-     */
-    offset: Animated.SharedValue<number>;
-    /**
-     * The next snapping value.
-     */
-    snappingTo: Animated.SharedValue<number>;
-    /**
-     * Height of the scrollable content of each tab. Helps to allow iOS bouncing.
-     */
-    contentHeights: Animated.SharedValue<number[]>;
-    contentInset: Animated.SharedValue<number>;
-    headerTranslateY: Animated.SharedValue<number>;
-    width: number;
-    /**
-     * Whether the header moves down during overscrolling (for example on pull-to-refresh on iOS) or sticks to the top
-     *
-     * @default false
-     */
-    allowHeaderOverscroll?: boolean;
-    minHeaderHeight: number;
+  headerHeight: Animated.SharedValue<number | undefined>;
+  tabBarHeight: Animated.SharedValue<number | undefined>;
+  revealHeaderOnScroll: boolean;
+  snapThreshold: number | null | undefined;
+  /**
+   * Index value, including decimal points. Use this to interpolate tab
+   * indicators.
+   */
+  indexDecimal: Animated.SharedValue<number>;
+  /**
+   * Tab names, same as the keys of `refMap`.
+   */
+  tabNames: Animated.SharedValue<T[]>;
+  /**
+   * Current index of the pager.
+   */
+  index: Animated.SharedValue<number>;
+  /**
+   * Name of the current focused tab.
+   */
+  focusedTab: Animated.SharedValue<T>;
+  /**
+   * DiffClamp value. It's the current visible header height if
+   * `diffClampEnabled={true}`.
+   */
+  accDiffClamp: Animated.SharedValue<number>;
+  /**
+   * Scroll position of current tab.
+   */
+  scrollYCurrent: Animated.SharedValue<number>;
+  /**
+   * Array of the scroll y position of each tab.
+   */
+  scrollY: Animated.SharedValue<number[]>;
+  containerHeight: Animated.SharedValue<number | undefined>;
+  /**
+   * Object containing the ref of each scrollable component.
+   */
+  refMap: Record<TabName, Ref<RefComponent>>;
+  /**
+   * Set the ref of the scrollable component.
+   */
+  setRef: <TComponent extends RefComponent>(
+    key: T,
+    ref: React.RefObject<TComponent>,
+  ) => Ref<TComponent>;
+  /**
+   * Max distance allowed to collapse the header.
+   */
+  headerScrollDistance: Animated.SharedValue<number>;
+  /**
+   * Previous addScrollY value.
+   */
+  oldAccScrollY: Animated.SharedValue<number>;
+  /**
+   * Accumulated scroll Y distance. Used to calculate the accDiffClamp value.
+   */
+  accScrollY: Animated.SharedValue<number>;
+  /**
+   * Offset to take the next scrollY as if it were at the same position of the
+   * previous tab.
+   */
+  offset: Animated.SharedValue<number>;
+  /**
+   * The next snapping value.
+   */
+  snappingTo: Animated.SharedValue<number>;
+  /**
+   * Height of the scrollable content of each tab. Helps to allow iOS bouncing.
+   */
+  contentHeights: Animated.SharedValue<number[]>;
+  contentInset: Animated.SharedValue<number>;
+  headerTranslateY: Animated.SharedValue<number>;
+  width: number;
+  /**
+   * Whether the header moves down during overscrolling (for example on pull-to-refresh on iOS) or sticks to the top
+   *
+   * @default false
+   */
+  allowHeaderOverscroll?: boolean;
+  minHeaderHeight: number;
 };
-export declare type ScrollViewProps = ComponentProps<typeof Animated.ScrollView>;
+export declare type ScrollViewProps = ComponentProps<
+  typeof Animated.ScrollView
+>;
 export declare type CollapsibleStyle = {
-    style: {
-        width: number;
-    };
-    contentContainerStyle: {
-        minHeight: number;
-        paddingTop: number;
-    };
-    progressViewOffset: number;
+  style: {
+    width: number;
+  };
+  contentContainerStyle: {
+    minHeight: number;
+    paddingTop: number;
+  };
+  progressViewOffset: number;
 };
-export declare type TabsWithProps<T extends TabName = TabName> = Map<T, Omit<TabProps<T>, 'children'> & {
+export declare type TabsWithProps<T extends TabName = TabName> = Map<
+  T,
+  Omit<TabProps<T>, "children"> & {
     index: number;
-}>;
+  }
+>;
 export declare type TabItemProps<T extends TabName> = {
-    name: T;
-    index: number;
-    indexDecimal: Animated.SharedValue<number>;
-    label: string | ((props: TabItemProps<T>) => React.ReactNode);
+  name: T;
+  index: number;
+  indexDecimal: Animated.SharedValue<number>;
+  label: string | ((props: TabItemProps<T>) => React.ReactNode);
 };
 export declare type TabProps<T extends TabName> = {
-    readonly name: T;
-    label?: TabItemProps<T>['label'];
-    children: React.ReactNode;
+  readonly name: T;
+  label?: TabItemProps<T>["label"];
+  children: React.ReactNode;
 };
diff --git a/node_modules/react-native-collapsible-tab-view/src/Container.tsx b/node_modules/react-native-collapsible-tab-view/src/Container.tsx
index 1023290..19b7067 100644
--- a/node_modules/react-native-collapsible-tab-view/src/Container.tsx
+++ b/node_modules/react-native-collapsible-tab-view/src/Container.tsx
@@ -1,42 +1,49 @@
-import React from 'react'
+import React, { useMemo } from "react";
 import {
   LayoutChangeEvent,
   StyleSheet,
   useWindowDimensions,
   View,
-} from 'react-native'
-import PagerView from 'react-native-pager-view'
+} from "react-native";
+import PagerView from "react-native-pager-view";
 import Animated, {
+  Extrapolate,
+  interpolate,
   runOnJS,
   runOnUI,
+  useAnimatedGestureHandler,
   useAnimatedReaction,
   useAnimatedStyle,
   useDerivedValue,
   useSharedValue,
+  withDecay,
   withDelay,
   withTiming,
-} from 'react-native-reanimated'
-
-import { Context, TabNameContext } from './Context'
-import { Lazy } from './Lazy'
-import { MaterialTabBar, TABBAR_HEIGHT } from './MaterialTabBar'
-import { Tab } from './Tab'
-import { IS_IOS, ONE_FRAME_MS, scrollToImpl } from './helpers'
+} from "react-native-reanimated";
+
+import { Context, TabNameContext } from "./Context";
+import { Lazy } from "./Lazy";
+import { MaterialTabBar, TABBAR_HEIGHT } from "./MaterialTabBar";
+import { Tab } from "./Tab";
+import { IS_IOS, ONE_FRAME_MS, scrollToImpl } from "./helpers";
+// import { TabBarContainer } from './TabBarContainer'
+// import { TopContainer } from './TopContainer'
 import {
   useAnimatedDynamicRefs,
   useContainerRef,
   usePageScrollHandler,
   useTabProps,
-} from './hooks'
+} from "./hooks";
 import {
   CollapsibleProps,
   CollapsibleRef,
   ContextType,
   IndexChangeEventData,
   TabName,
-} from './types'
+} from "./types";
+import { Gesture, GestureDetector } from "react-native-gesture-handler";
 
-const AnimatedPagerView = Animated.createAnimatedComponent(PagerView)
+const AnimatedPagerView = Animated.createAnimatedComponent(PagerView);
 
 /**
  * Basic usage looks like this:
@@ -65,6 +72,7 @@ export const Container = React.memo(
         initialTabName,
         headerHeight: initialHeaderHeight,
         minHeaderHeight = 0,
+        hasTouchableHeader,
         tabBarHeight: initialTabBarHeight = TABBAR_HEIGHT,
         revealHeaderOnScroll = false,
         snapThreshold,
@@ -82,114 +90,119 @@ export const Container = React.memo(
         width: customWidth,
         allowHeaderOverscroll,
       },
-      ref
+      ref,
     ) => {
-      const containerRef = useContainerRef()
+      const containerRef = useContainerRef();
 
-      const [tabProps, tabNamesArray] = useTabProps(children, Tab)
+      const [tabProps, tabNamesArray] = useTabProps(children, Tab);
 
-      const [refMap, setRef] = useAnimatedDynamicRefs()
+      const [refMap, setRef] = useAnimatedDynamicRefs();
 
-      const windowWidth = useWindowDimensions().width
-      const width = customWidth ?? windowWidth
+      const windowWidth = useWindowDimensions().width;
+      const width = customWidth ?? windowWidth;
 
-      const containerHeight = useSharedValue<number | undefined>(undefined)
+      const containerHeight = useSharedValue<number | undefined>(undefined);
 
       const tabBarHeight = useSharedValue<number | undefined>(
-        initialTabBarHeight
-      )
+        initialTabBarHeight,
+      );
 
       const headerHeight = useSharedValue<number | undefined>(
-        !renderHeader ? 0 : initialHeaderHeight
-      )
+        !renderHeader ? 0 : initialHeaderHeight,
+      );
 
       const contentInset = useDerivedValue(() => {
-        if (allowHeaderOverscroll) return 0
+        if (allowHeaderOverscroll) return 0;
 
         // necessary for the refresh control on iOS to be positioned underneath the header
         // this also adjusts the scroll bars to clamp underneath the header area
         return IS_IOS
           ? (headerHeight.value || 0) + (tabBarHeight.value || 0)
-          : 0
-      })
-
-      const snappingTo: ContextType['snappingTo'] = useSharedValue(0)
-      const offset: ContextType['offset'] = useSharedValue(0)
-      const accScrollY: ContextType['accScrollY'] = useSharedValue(0)
-      const oldAccScrollY: ContextType['oldAccScrollY'] = useSharedValue(0)
-      const accDiffClamp: ContextType['accDiffClamp'] = useSharedValue(0)
-      const scrollYCurrent: ContextType['scrollYCurrent'] = useSharedValue(0)
-      const scrollY: ContextType['scrollY'] = useSharedValue(
-        tabNamesArray.map(() => 0)
-      )
-
-      const contentHeights: ContextType['contentHeights'] = useSharedValue(
-        tabNamesArray.map(() => 0)
-      )
-
-      const tabNames: ContextType['tabNames'] = useDerivedValue<TabName[]>(
+          : 0;
+      });
+
+      const snappingTo: ContextType["snappingTo"] = useSharedValue(0);
+      const offset: ContextType["offset"] = useSharedValue(0);
+      const accScrollY: ContextType["accScrollY"] = useSharedValue(0);
+      const oldAccScrollY: ContextType["oldAccScrollY"] = useSharedValue(0);
+      const accDiffClamp: ContextType["accDiffClamp"] = useSharedValue(0);
+      const scrollYCurrent: ContextType["scrollYCurrent"] = useSharedValue(0);
+      const scrollY: ContextType["scrollY"] = useSharedValue(
+        tabNamesArray.map(() => 0),
+      );
+      const isSlidingTopContainer = useSharedValue(false);
+      const isSlidingTopContainerPrev = useSharedValue(false);
+      const isTopContainerOutOfSync = useSharedValue(false);
+
+      const contentHeights: ContextType["contentHeights"] = useSharedValue(
+        tabNamesArray.map(() => 0),
+      );
+
+      const tabNames: ContextType["tabNames"] = useDerivedValue<TabName[]>(
         () => tabNamesArray,
-        [tabNamesArray]
-      )
-      const index: ContextType['index'] = useSharedValue(
+        [tabNamesArray],
+      );
+      const index: ContextType["index"] = useSharedValue(
         initialTabName
           ? tabNames.value.findIndex((n) => n === initialTabName)
-          : 0
-      )
+          : 0,
+      );
 
-      const [data, setData] = React.useState(tabNamesArray)
+      const [data, setData] = React.useState(tabNamesArray);
 
       React.useEffect(() => {
-        setData(tabNamesArray)
-      }, [tabNamesArray])
-
-      const focusedTab: ContextType['focusedTab'] = useDerivedValue<TabName>(() => {
-        return tabNames.value[index.value]
-      }, [tabNames])
-      const calculateNextOffset = useSharedValue(index.value)
-      const headerScrollDistance: ContextType['headerScrollDistance'] = useDerivedValue(() => {
-        return headerHeight.value !== undefined
-          ? headerHeight.value - minHeaderHeight
-          : 0
-      }, [headerHeight, minHeaderHeight])
-
-      const indexDecimal: ContextType['indexDecimal'] = useSharedValue(
-        index.value
-      )
-
-      const afterRender = useSharedValue(0)
+        setData(tabNamesArray);
+      }, [tabNamesArray]);
+
+      const focusedTab: ContextType["focusedTab"] =
+        useDerivedValue<TabName>(() => {
+          return tabNames.value[index.value];
+        }, [tabNames]);
+      const calculateNextOffset = useSharedValue(index.value);
+      const headerScrollDistance: ContextType["headerScrollDistance"] =
+        useDerivedValue(() => {
+          return headerHeight.value !== undefined
+            ? headerHeight.value - minHeaderHeight
+            : 0;
+        }, [headerHeight, minHeaderHeight]);
+
+      const indexDecimal: ContextType["indexDecimal"] = useSharedValue(
+        index.value,
+      );
+
+      const afterRender = useSharedValue(0);
       React.useEffect(() => {
         afterRender.value = withDelay(
           ONE_FRAME_MS * 5,
-          withTiming(1, { duration: 0 })
-        )
-      }, [afterRender, tabNamesArray])
+          withTiming(1, { duration: 0 }),
+        );
+      }, [afterRender, tabNamesArray]);
 
       const resyncTabScroll = () => {
-        'worklet'
+        "worklet";
         for (const name of tabNamesArray) {
           scrollToImpl(
             refMap[name],
             0,
             scrollYCurrent.value - contentInset.value,
-            false
-          )
+            false,
+          );
         }
-      }
+      };
 
       // the purpose of this is to scroll to the proper position if dynamic tabs are changing
       useAnimatedReaction(
         () => {
-          return afterRender.value === 1
+          return afterRender.value === 1;
         },
         (trigger) => {
           if (trigger) {
-            afterRender.value = 0
-            resyncTabScroll()
+            afterRender.value = 0;
+            resyncTabScroll();
           }
         },
-        [tabNamesArray, refMap, afterRender, contentInset]
-      )
+        [tabNamesArray, refMap, afterRender, contentInset],
+      );
 
       // derived from scrollX
       // calculate the next offset and index if swiping
@@ -198,61 +211,61 @@ export const Container = React.memo(
       // the next index in advance
       useAnimatedReaction(
         () => {
-          const nextIndex = Math.round(indexDecimal.value)
-          return nextIndex
+          const nextIndex = Math.round(indexDecimal.value);
+          return nextIndex;
         },
         (nextIndex) => {
           if (nextIndex !== null && nextIndex !== index.value) {
-            calculateNextOffset.value = nextIndex
+            calculateNextOffset.value = nextIndex;
           }
         },
-        []
-      )
+        [],
+      );
 
       const propagateTabChange = React.useCallback(
         (change: IndexChangeEventData<TabName>) => {
-          onTabChange?.(change)
-          onIndexChange?.(change.index)
+          onTabChange?.(change);
+          onIndexChange?.(change.index);
         },
-        [onIndexChange, onTabChange]
-      )
+        [onIndexChange, onTabChange],
+      );
 
       useAnimatedReaction(
         () => {
-          return calculateNextOffset.value
+          return calculateNextOffset.value;
         },
         (i) => {
           if (i !== index.value) {
             offset.value =
-              scrollY.value[index.value] - scrollY.value[i] + offset.value
+              scrollY.value[index.value] - scrollY.value[i] + offset.value;
             runOnJS(propagateTabChange)({
               prevIndex: index.value,
               index: i,
               prevTabName: tabNames.value[index.value],
               tabName: tabNames.value[i],
-            })
-            index.value = i
-            scrollYCurrent.value = scrollY.value[index.value] || 0
+            });
+            index.value = i;
+            scrollYCurrent.value = scrollY.value[index.value] || 0;
           }
         },
-        []
-      )
+        [],
+      );
 
       useAnimatedReaction(
         () => headerHeight.value,
         (_current, prev) => {
           if (prev === undefined) {
             // sync scroll if we started with undefined header height
-            resyncTabScroll()
+            resyncTabScroll();
           }
-        }
-      )
+        },
+      );
 
       const headerTranslateY = useDerivedValue(() => {
         return revealHeaderOnScroll
           ? -accDiffClamp.value
-          : -Math.min(scrollYCurrent.value, headerScrollDistance.value)
-      }, [revealHeaderOnScroll])
+          : -Math.min(scrollYCurrent.value, headerScrollDistance.value);
+      }, [revealHeaderOnScroll]);
 
       const stylez = useAnimatedStyle(() => {
         return {
@@ -261,90 +274,207 @@ export const Container = React.memo(
               translateY: headerTranslateY.value,
             },
           ],
-        }
-      }, [revealHeaderOnScroll])
+        };
+      }, [revealHeaderOnScroll]);
 
       const getHeaderHeight = React.useCallback(
         (event: LayoutChangeEvent) => {
-          const height = event.nativeEvent.layout.height
+          const height = event.nativeEvent.layout.height;
           if (headerHeight.value !== height) {
-            headerHeight.value = height
+            headerHeight.value = height;
           }
         },
-        [headerHeight]
-      )
+        [headerHeight],
+      );
 
       const getTabBarHeight = React.useCallback(
         (event: LayoutChangeEvent) => {
-          const height = event.nativeEvent.layout.height
-          if (tabBarHeight.value !== height) tabBarHeight.value = height
+          const height = event.nativeEvent.layout.height;
+          if (tabBarHeight.value !== height) tabBarHeight.value = height;
         },
-        [tabBarHeight]
-      )
+        [tabBarHeight],
+      );
 
       const onLayout = React.useCallback(
         (event: LayoutChangeEvent) => {
-          const height = event.nativeEvent.layout.height
-          if (containerHeight.value !== height) containerHeight.value = height
+          const height = event.nativeEvent.layout.height;
+          if (containerHeight.value !== height) containerHeight.value = height;
         },
-        [containerHeight]
-      )
+        [containerHeight],
+      );
 
       const onTabPress = React.useCallback(
         (name: TabName) => {
-          const i = tabNames.value.findIndex((n) => n === name)
+          const i = tabNames.value.findIndex((n) => n === name);
 
           if (name === focusedTab.value) {
-            const ref = refMap[name]
+            const ref = refMap[name];
             runOnUI(scrollToImpl)(
               ref,
               0,
               headerScrollDistance.value - contentInset.value,
-              true
-            )
+              true,
+            );
           } else {
-            containerRef.current?.setPage(i)
+            containerRef.current?.setPage(i);
           }
         },
         // eslint-disable-next-line react-hooks/exhaustive-deps
-        [containerRef, refMap, contentInset]
-      )
+        [containerRef, refMap, contentInset],
+      );
 
       React.useEffect(() => {
         if (index.value >= tabNamesArray.length) {
-          onTabPress(tabNamesArray[tabNamesArray.length - 1])
+          onTabPress(tabNamesArray[tabNamesArray.length - 1]);
         }
-      }, [index.value, onTabPress, tabNamesArray])
+      }, [index.value, onTabPress, tabNamesArray]);
 
       const pageScrollHandler = usePageScrollHandler({
         onPageScroll: (e) => {
-          'worklet'
-          indexDecimal.value = e.position + e.offset
+          "worklet";
+          indexDecimal.value = e.position + e.offset;
         },
-      })
+      });
 
       React.useImperativeHandle(
         ref,
         () => ({
           setIndex: (index) => {
-            const name = tabNames.value[index]
-            onTabPress(name)
-            return true
+            const name = tabNames.value[index];
+            onTabPress(name);
+            return true;
           },
           jumpToTab: (name) => {
-            onTabPress(name)
-            return true
+            onTabPress(name);
+            return true;
           },
           getFocusedTab: () => {
-            return tabNames.value[index.value]
+            return tabNames.value[index.value];
           },
           getCurrentIndex: () => {
-            return index.value
+            return index.value;
           },
         }),
         // eslint-disable-next-line react-hooks/exhaustive-deps
-        [onTabPress]
-      )
+        [onTabPress],
+      );
+
+      const panGestureScrollYCtx = useSharedValue(0);
+      const panGesture = useMemo(
+        () =>
+          Gesture.Pan()
+            .activeOffsetY([-10, 10])
+            .onUpdate((event) => {
+              if (!isSlidingTopContainer.value) {
+                panGestureScrollYCtx.value = scrollYCurrent.value;
+                isSlidingTopContainer.value = true;
+                return;
+              }
+
+              scrollYCurrent.value = interpolate(
+                -event.translationY + panGestureScrollYCtx.value,
+                [0, headerScrollDistance.value],
+                [0, headerScrollDistance.value],
+                Extrapolate.CLAMP,
+              );
+            })
+            .onEnd((event) => {
+              if (!isSlidingTopContainer.value) return;
+
+              panGestureScrollYCtx.value = 0;
+              scrollYCurrent.value = withDecay(
+                {
+                  velocity: -event.velocityY,
+                  clamp: [0, headerScrollDistance.value],
+                  deceleration: IS_IOS ? 0.998 : 0.99,
+                },
+                (finished) => {
+                  isSlidingTopContainer.value = false;
+                  isTopContainerOutOfSync.value = finished;
+                },
+              );
+            }),
+        [],
+      );
+
+      useAnimatedReaction(
+        () => scrollYCurrent.value - contentInset.value,
+        (nextPosition, previousPosition) => {
+          if (
+            nextPosition !== previousPosition &&
+            isSlidingTopContainer.value
+          ) {
+            resyncTabScroll();
+          }
+        },
+      );
+
+      /* Syncs the scroll of the active tab once we complete the scroll gesture 
+  on the header and the decay animation completes with success
+   */
+      useAnimatedReaction(
+        () => {
+          return (
+            isSlidingTopContainer.value !== isSlidingTopContainerPrev.value &&
+            isTopContainerOutOfSync.value
+          );
+        },
+        (result) => {
+          isSlidingTopContainerPrev.value = isSlidingTopContainer.value;
+
+          if (!result) return;
+          if (isSlidingTopContainer.value === true) return;
+
+          resyncTabScroll();
+
+          isTopContainerOutOfSync.value = false;
+        },
+      );
+
+      const headerAndTabBar = (
+        <Animated.View
+          pointerEvents="box-none"
+          style={[
+            styles.topContainer,
+            headerContainerStyle,
+            !cancelTranslation && stylez,
+          ]}
+        >
+          <View
+            style={[styles.container, styles.headerContainer]}
+            onLayout={getHeaderHeight}
+            pointerEvents="box-none"
+          >
+            {renderHeader &&
+              renderHeader({
+                containerRef,
+                index,
+                tabNames: tabNamesArray,
+                focusedTab,
+                indexDecimal,
+                onTabPress,
+                tabProps,
+              })}
+          </View>
+          <View
+            style={[styles.container, styles.tabBarContainer]}
+            onLayout={getTabBarHeight}
+            pointerEvents="box-none"
+          >
+            {renderTabBar &&
+              renderTabBar({
+                containerRef,
+                index,
+                tabNames: tabNamesArray,
+                focusedTab,
+                indexDecimal,
+                width,
+                onTabPress,
+                tabProps,
+              })}
+          </View>
+        </Animated.View>
+      );
 
       return (
         <Context.Provider
@@ -381,49 +511,13 @@ export const Container = React.memo(
             onLayout={onLayout}
             pointerEvents="box-none"
           >
-            <Animated.View
-              pointerEvents="box-none"
-              style={[
-                styles.topContainer,
-                headerContainerStyle,
-                !cancelTranslation && stylez,
-              ]}
-            >
-              <View
-                style={[styles.container, styles.headerContainer]}
-                onLayout={getHeaderHeight}
-                pointerEvents="box-none"
-              >
-                {renderHeader &&
-                  renderHeader({
-                    containerRef,
-                    index,
-                    tabNames: tabNamesArray,
-                    focusedTab,
-                    indexDecimal,
-                    onTabPress,
-                    tabProps,
-                  })}
-              </View>
-              <View
-                style={[styles.container, styles.tabBarContainer]}
-                onLayout={getTabBarHeight}
-                pointerEvents="box-none"
-              >
-                {renderTabBar &&
-                  renderTabBar({
-                    containerRef,
-                    index,
-                    tabNames: tabNamesArray,
-                    focusedTab,
-                    indexDecimal,
-                    width,
-                    onTabPress,
-                    tabProps,
-                  })}
-              </View>
-            </Animated.View>
-
+            {hasTouchableHeader ? (
+              <GestureDetector gesture={panGesture}>
+                {headerAndTabBar}
+              </GestureDetector>
+            ) : (
+              headerAndTabBar
+            )}
             <AnimatedPagerView
               ref={containerRef}
               onPageScroll={pageScrollHandler}
@@ -447,33 +541,24 @@ export const Container = React.memo(
                       </Lazy>
                     </TabNameContext.Provider>
                   </View>
-                )
+                );
               })}
             </AnimatedPagerView>
           </Animated.View>
         </Context.Provider>
-      )
-    }
-  )
-)
+      );
+    },
+  ),
+);
 
 const styles = StyleSheet.create({
   container: {
     flex: 1,
   },
   topContainer: {
-    position: 'absolute',
+    position: "absolute",
     zIndex: 100,
-    width: '100%',
-    backgroundColor: 'white',
-    shadowColor: '#000000',
-    shadowOffset: {
-      width: 0,
-      height: 2,
-    },
-    shadowOpacity: 0.23,
-    shadowRadius: 2.62,
-    elevation: 4,
+    width: "100%",
   },
   tabBarContainer: {
     zIndex: 1,
@@ -481,4 +566,4 @@ const styles = StyleSheet.create({
   headerContainer: {
     zIndex: 2,
   },
-})
+});
diff --git a/node_modules/react-native-collapsible-tab-view/src/types.ts b/node_modules/react-native-collapsible-tab-view/src/types.ts
index 4cf32ee..808097f 100644
--- a/node_modules/react-native-collapsible-tab-view/src/types.ts
+++ b/node_modules/react-native-collapsible-tab-view/src/types.ts
@@ -1,252 +1,256 @@
-import React, { ComponentProps } from 'react'
+import React, { ComponentProps } from "react";
 import {
   FlatList,
   ScrollView,
   SectionList,
   StyleProp,
   ViewStyle,
-} from 'react-native'
-import PagerView, { PagerViewProps } from 'react-native-pager-view'
-import Animated from 'react-native-reanimated'
+} from "react-native";
+import PagerView, { PagerViewProps } from "react-native-pager-view";
+import Animated from "react-native-reanimated";
 
-export type ContainerRef = PagerView
+export type ContainerRef = PagerView;
 
 export type RefComponent =
   | FlatList<any>
   | ScrollView
   | Animated.ScrollView
-  | SectionList<any>
+  | SectionList<any>;
 
-export type Ref<T extends RefComponent> = React.RefObject<T>
+export type Ref<T extends RefComponent> = React.RefObject<T>;
 
-export type TabName = string
+export type TabName = string;
 
 export type RefHandler<T extends TabName = TabName> = {
-  jumpToTab: (name: T) => boolean
-  setIndex: (index: number) => boolean
-  getFocusedTab: () => T
-  getCurrentIndex: () => number
-}
+  jumpToTab: (name: T) => boolean;
+  setIndex: (index: number) => boolean;
+  getFocusedTab: () => T;
+  getCurrentIndex: () => number;
+};
 
 export type CollapsibleRef<T extends TabName = TabName> =
   | RefHandler<T>
-  | undefined
+  | undefined;
 
 export type TabBarProps<T extends TabName = TabName> = {
-  indexDecimal: Animated.SharedValue<number>
-  focusedTab: Animated.SharedValue<T>
-  tabNames: T[]
-  index: Animated.SharedValue<number>
-  containerRef: React.RefObject<ContainerRef>
-  onTabPress: (name: T) => void
-  tabProps: TabsWithProps<T>
+  indexDecimal: Animated.SharedValue<number>;
+  focusedTab: Animated.SharedValue<T>;
+  tabNames: T[];
+  index: Animated.SharedValue<number>;
+  containerRef: React.RefObject<ContainerRef>;
+  onTabPress: (name: T) => void;
+  tabProps: TabsWithProps<T>;
 
   /**
    * Custom width of the tabbar. Defaults to the window width.
    */
-  width?: number
-}
+  width?: number;
+};
 
 export type IndexChangeEventData<T extends TabName = TabName> = {
-  prevIndex: number
-  index: number
-  prevTabName: T
-  tabName: T
-}
+  prevIndex: number;
+  index: number;
+  prevTabName: T;
+  tabName: T;
+};
 
 export type OnTabChangeCallback<T extends TabName = TabName> = (
-  data: IndexChangeEventData<T>
-) => void
+  data: IndexChangeEventData<T>,
+) => void;
 
 export type TabReactElement<T extends TabName = TabName> = React.ReactElement<
   TabProps<T>
-> | null
+> | null;
 
 export type CollapsibleProps = {
-  initialTabName?: TabName
+  initialTabName?: TabName;
   /**
    * Is optional, but will optimize the first render.
    */
-  headerHeight?: number
+  headerHeight?: number;
   /**
    * Is optional, but will optimize the first render.
    */
-  tabBarHeight?: number
+  tabBarHeight?: number;
   /**
    * Header minimum height when collapsed
    */
-  minHeaderHeight?: number
+  minHeaderHeight?: number;
   /**
    * Reveal header when scrolling down. Implements diffClamp.
    */
-  revealHeaderOnScroll?: boolean
+  revealHeaderOnScroll?: boolean;
+  /**
+   * Allows the header to be scrollable
+   */
+  hasTouchableHeader?: boolean;
   /**
    * Percentage of header height to define as the snap point. A number between
    * 0 and 1, or `null` to disable snapping.
    * @default null
    */
-  snapThreshold?: number | null
-  children: TabReactElement<TabName>[] | TabReactElement<TabName>
+  snapThreshold?: number | null;
+  children: TabReactElement<TabName>[] | TabReactElement<TabName>;
 
-  renderHeader?: (props: TabBarProps<TabName>) => React.ReactElement | null
+  renderHeader?: (props: TabBarProps<TabName>) => React.ReactElement | null;
 
-  renderTabBar?: (props: TabBarProps<TabName>) => React.ReactElement | null
+  renderTabBar?: (props: TabBarProps<TabName>) => React.ReactElement | null;
 
-  headerContainerStyle?: StyleProp<Animated.AnimateStyle<ViewStyle>>
-  containerStyle?: StyleProp<ViewStyle>
-  cancelTranslation?: boolean
+  headerContainerStyle?: StyleProp<Animated.AnimateStyle<ViewStyle>>;
+  containerStyle?: StyleProp<ViewStyle>;
+  cancelTranslation?: boolean;
   /**
    * If lazy, will mount the screens only when the tab is visited. There is a
    * default fade in transition.
    */
-  lazy?: boolean
-  cancelLazyFadeIn?: boolean
+  lazy?: boolean;
+  cancelLazyFadeIn?: boolean;
   /**
    * Props passed to the pager. If you want for example to
    * disable swiping, you can pass `{ scrollEnabled: false }`
    */
-  pagerProps?: Omit<PagerViewProps, 'onPageScroll' | 'initialPage'>
+  pagerProps?: Omit<PagerViewProps, "onPageScroll" | "initialPage">;
   /**
    * Callback fired when the index changes. It receives the current index.
    */
-  onIndexChange?: (index: number) => void
+  onIndexChange?: (index: number) => void;
 
   /**
    * Callback fired when the tab changes. It receives the previous and current
    *  index and tabnames.
    */
-  onTabChange?: OnTabChangeCallback<TabName>
+  onTabChange?: OnTabChangeCallback<TabName>;
 
   /**
    * Custom width of the container. Defaults to the window width.
    */
-  width?: number
+  width?: number;
 
   /**
    * Whether the header moves down during overscrolling (for example on pull-to-refresh on iOS) or sticks to the top
    *
    * @default false
    */
-  allowHeaderOverscroll?: boolean
-}
+  allowHeaderOverscroll?: boolean;
+};
 
 export type ContextType<T extends TabName = TabName> = {
-  headerHeight: Animated.SharedValue<number | undefined>
-  tabBarHeight: Animated.SharedValue<number | undefined>
-  revealHeaderOnScroll: boolean
-  snapThreshold: number | null | undefined
+  headerHeight: Animated.SharedValue<number | undefined>;
+  tabBarHeight: Animated.SharedValue<number | undefined>;
+  revealHeaderOnScroll: boolean;
+  snapThreshold: number | null | undefined;
   /**
    * Index value, including decimal points. Use this to interpolate tab
    * indicators.
    */
-  indexDecimal: Animated.SharedValue<number>
+  indexDecimal: Animated.SharedValue<number>;
   /**
    * Tab names, same as the keys of `refMap`.
    */
-  tabNames: Animated.SharedValue<T[]>
+  tabNames: Animated.SharedValue<T[]>;
   /**
    * Current index of the pager.
    */
-  index: Animated.SharedValue<number>
+  index: Animated.SharedValue<number>;
   /**
    * Name of the current focused tab.
    */
-  focusedTab: Animated.SharedValue<T>
+  focusedTab: Animated.SharedValue<T>;
   /**
    * DiffClamp value. It's the current visible header height if
    * `diffClampEnabled={true}`.
    */
-  accDiffClamp: Animated.SharedValue<number>
+  accDiffClamp: Animated.SharedValue<number>;
   /**
    * Scroll position of current tab.
    */
-  scrollYCurrent: Animated.SharedValue<number>
+  scrollYCurrent: Animated.SharedValue<number>;
   /**
    * Array of the scroll y position of each tab.
    */
-  scrollY: Animated.SharedValue<number[]>
-  containerHeight: Animated.SharedValue<number | undefined>
+  scrollY: Animated.SharedValue<number[]>;
+  containerHeight: Animated.SharedValue<number | undefined>;
   /**
    * Object containing the ref of each scrollable component.
    */
-  refMap: Record<TabName, Ref<RefComponent>>
+  refMap: Record<TabName, Ref<RefComponent>>;
   /**
    * Set the ref of the scrollable component.
    */
   setRef: <TComponent extends RefComponent>(
     key: T,
-    ref: React.RefObject<TComponent>
-  ) => Ref<TComponent>
+    ref: React.RefObject<TComponent>,
+  ) => Ref<TComponent>;
   /**
    * Max distance allowed to collapse the header.
    */
-  headerScrollDistance: Animated.SharedValue<number>
+  headerScrollDistance: Animated.SharedValue<number>;
   /**
    * Previous addScrollY value.
    */
-  oldAccScrollY: Animated.SharedValue<number>
+  oldAccScrollY: Animated.SharedValue<number>;
   /**
    * Accumulated scroll Y distance. Used to calculate the accDiffClamp value.
    */
-  accScrollY: Animated.SharedValue<number>
+  accScrollY: Animated.SharedValue<number>;
   /**
    * Offset to take the next scrollY as if it were at the same position of the
    * previous tab.
    */
-  offset: Animated.SharedValue<number>
+  offset: Animated.SharedValue<number>;
 
   /**
    * The next snapping value.
    */
-  snappingTo: Animated.SharedValue<number>
+  snappingTo: Animated.SharedValue<number>;
 
   /**
    * Height of the scrollable content of each tab. Helps to allow iOS bouncing.
    */
-  contentHeights: Animated.SharedValue<number[]>
+  contentHeights: Animated.SharedValue<number[]>;
 
-  contentInset: Animated.SharedValue<number>
+  contentInset: Animated.SharedValue<number>;
 
-  headerTranslateY: Animated.SharedValue<number>
+  headerTranslateY: Animated.SharedValue<number>;
 
-  width: number
+  width: number;
 
   /**
    * Whether the header moves down during overscrolling (for example on pull-to-refresh on iOS) or sticks to the top
    *
    * @default false
    */
-  allowHeaderOverscroll?: boolean
+  allowHeaderOverscroll?: boolean;
 
-  minHeaderHeight: number
-}
+  minHeaderHeight: number;
+};
 
-export type ScrollViewProps = ComponentProps<typeof Animated.ScrollView>
+export type ScrollViewProps = ComponentProps<typeof Animated.ScrollView>;
 
 export type CollapsibleStyle = {
-  style: { width: number }
+  style: { width: number };
   contentContainerStyle: {
-    minHeight: number
-    paddingTop: number
-  }
-  progressViewOffset: number
-}
+    minHeight: number;
+    paddingTop: number;
+  };
+  progressViewOffset: number;
+};
 
 export type TabsWithProps<T extends TabName = TabName> = Map<
   T,
-  Omit<TabProps<T>, 'children'> & { index: number }
->
+  Omit<TabProps<T>, "children"> & { index: number }
+>;
 
 export type TabItemProps<T extends TabName> = {
-  name: T
-  index: number
-  indexDecimal: Animated.SharedValue<number>
+  name: T;
+  index: number;
+  indexDecimal: Animated.SharedValue<number>;
 
-  label: string | ((props: TabItemProps<T>) => React.ReactNode)
-}
+  label: string | ((props: TabItemProps<T>) => React.ReactNode);
+};
 
 export type TabProps<T extends TabName> = {
-  readonly name: T
-  label?: TabItemProps<T>['label']
-  children: React.ReactNode
-}
+  readonly name: T;
+  label?: TabItemProps<T>["label"];
+  children: React.ReactNode;
+};
